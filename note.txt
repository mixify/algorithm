set은 insert를 사용한다!!!!

int A[11][11];// 1부터 시작하는거는 헤깔리지 말게 이렇게 풀자 앞으로...

// 자료구조가 루프를 돌면서 변형되는 거라면 잘 고려하자 복사를 하던

for (idx_itr = tree.begin(); idx_itr != tree.end();)//set 은 !=로 순회 검사
    tree_itr = tree_on_land[idx_itr->first][idx_itr->second].erase(tree_itr);
    // erase 리턴값으로 꼭 가야한다 까먹지 말자 시벌

str.append(1,panel[x][y]+'0'); // string에 char 한글짜식 추가하는 방법임!

cout>>max_idx.top();//stack 은 제이랑피 top이다

그냥 queue 는 순회가 안된다~~~~
int amount = stoi(str.substr(1,str.length()-1)); string to ascii~~

<algorithm> => lower_bound, upper_bound 사용 가능~~ lower_bound 는 크거나
같은수를 구함~~~ upper_bound는 무조건 큰수만~~ 둘다 위치를 구해줌~~
vector<int>(1,ori) ori 로 초기화된 1개의 원소를 가지는 벡터

ios::sync_with_stdio(false);
cin.tie(NULL); => cin 속도 개선

bool compare 를 만들어서 정렬을 오름차순, 내림차순 할 수 있다.


이거시 바로 조합생성 알고리즘
vector <vector<int> > combination(int n, int r)
{
    vector <vector<int> > comb;
    vector <int> num;
    for (int i = 0; i < n; ++i) {
        num.push_back(i);
    }
    vector<int> ind;

    for (int i = 0; i < r; ++i) {
        ind.push_back(1);
    }
    for (int i = 0; i < n-r; ++i) {
        ind.push_back(0);
    }

    sort(ind.begin(),ind.end());

    do{
        vector<int> one_comb;
        for (int i = 0; i < ind.size(); ++i) {
            if(ind[i] == 1)
                one_comb.push_back(num[i]);
        }
        comb.push_back(one_comb);
    }while(next_permutation(ind.begin(),ind.end()));

    return comb;
}

compare 함수 override 할때 오름차순 => < 로 한다~~~~~
